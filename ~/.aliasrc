#!/usr/bin/env bash
#######################
# Functions & Aliases #
#######################

# ------------------------------------------------------------------------------
_alias=$(realpath "${BASH_SOURCE:-$0}")
_dotfiles=$(dirname "$_alias")

# ------------------------------------------------------------------------------
# Detect OS type

ostype() {
    local _os;

    case "$OSTYPE" in
        solaris*) _os=sun ;;
        darwin*)  _os=osx ;;
        linux*)   _os=linux ;;
        bsd*)     _os=bsd ;;
        msys*)    _os=windows ;;
        *)        _os=$(uname)
            case "$_os" in
                Linux*)           _os=linux ;;
                Darwin*)          _os=osx ;;
                FreeBSD|OpenBSD)  _os=bsd ;;
                SunOS)            _os=sun ;;
                MINGW32_NT*)      _os=windows ;;
                *)       _os="${_os,,}" ;;
                # *)       _os=$(echo "$_os" | awk '{print tolower($0)}') ;;
            esac
        ;;
    esac

    echo "$_os";
}

_os=$(ostype)

# bash only, but cool :-)
if_os () { [[ $OSTYPE == *$1* ]]; }
if_nix () {
    case "$OSTYPE" in
        *linux*|*hurd*|*msys*|*cygwin*|*sua*|*interix*) sys="gnu";;
        *bsd*|*darwin*) sys="bsd";;
        *sunos*|*solaris*|*indiana*|*illumos*|*smartos*) sys="sun";;
    esac
    [[ "${sys}" == "$1" ]];
}

# ------------------------------------------------------------------------------
# Guess the shell type - doesn't quite work in subshells (when not your login shell)
shelltype() {
    if [ -n "$ZSH_NAME" ] || [ -n "$ZSH_VERSION" ]; then
        echo 'zsh'
    elif [ -n "${BASH_SOURCE:-}" ] || [ -n "$BASH" ]; then
        echo 'bash'
    else
        local s;
        s=$(realpath /proc/$$/exe); # it's safer to check real processes' path
        if [ -n "$s" ] && [ "$s" != "/proc/$$/exe" ] && [ -e "$s" ]; then
            # echo "${s##*/}"
            basename "$s"
        elif [ -n "$shell" ]; then
            # echo "${shell##*/}"
            basename "$shell"
        elif [ -n "$SHELL" ]; then
            basename "$(realpath "$SHELL")"
        else
            echo 'sh'; # unknown
            return 1;
        fi
    fi
}

_shell=$(shelltype)

# ------------------------------------------------------------------------------
# "Edit this file" command
alias aliasrc='edit ~/.aliasrc; . ~/.aliasrc'

# ------------------------------------------------------------------------------

# echo to stderr
echo_error() {
    >&2 echo "$@"
}

# ------------------------------------------------------------------------------
# Portable ls with colors
if ls --color -d . >/dev/null 2>&1; then
    alias ls='ls --color=auto'  # Linux
    # alias ls="ls --color=tty"
elif ls -G -d . >/dev/null 2>&1; then
    alias ls='ls -G'  # BSD/OS X
fi

alias la="ls -ahF"
alias ll="ls -lhF"
alias l='ll -a'
alias l.="ls -dh .*"

alias s='systemctl'
alias j='journalctl'
alias sud='sudo -s'
alias t='tail -n 100 -f'

alias more="less -MNE~"

# Recognize "more" typos
alias mroe=more
alias moer=more
alias mreo=more

## Colorize the grep command output for ease of use (good for log files)##
if echo | grep --color 2> /dev/null; then
    alias grep  > /dev/null 2>&1 || alias grep='grep --color=auto'
    alias egrep > /dev/null 2>&1 || alias egrep='egrep --color=auto'
    alias egrep > /dev/null 2>&1 || alias fgrep='fgrep --color=auto'
fi

alias nocmt="grep -Ev '^(#|$)'" # grep no comment

## df & du human readable
if [ "$_os" = "osx" ] || [ "$_os" = "bsd" ]; then
    alias df='df -H'
    alias dfh='df -Hl'
    # alias dft='df -Hl | head -1; df -Hl --total | grep total'
else
    alias df='df -h'
    alias dfh='df -hlT -x tmpfs -x devtmpfs -x overlay'
    alias dft='df -hl | head -1; df -hl -x tmpfs -x devtmpfs -x overlay --total | grep total'
fi

alias du='du -ch'
alias du1='du -d 1'
alias du0='du -d 0'
# alias dut='du -hsx * | sort -rh | head' # See fs() function below
alias dut='fs -h -x'


# Add safety nets:

## do not delete / or prompt if deleting more than 3 files at a time #
if rm --help 2> /dev/null | grep -q -- '--preserve-root';
then
    alias rm='rm -I --preserve-root'
fi

## Parenting changing perms on / #
if chown --help 2> /dev/null | grep -q -- '--preserve-root';
then
    alias chown='chown --preserve-root'
    alias chmod='chmod --preserve-root'
    alias chgrp='chgrp --preserve-root'
fi

## confirmation #
alias mv='mv -i'
alias cp='cp -i'
ln --help 2> /dev/null | grep -q -- '--interactive' && alias ln='ln -i'

# Git
alias g="git"
alias gva="git status"
alias gv="gva ."
alias gvs="gv -s"
alias gda="git diff"
alias gdan="gda --name-status"
alias gd="gda ."
alias gdn="gdan ."
alias gdao="gda --cached"
alias gdo="gdao ."
alias ga="git add"
alias gap="ga -p"
alias gaa="ga --all"
alias guna="git rm --cached" # unadd
alias gunaa="git rm -r --cached ." # unadd all
alias gc="git commit"
alias gcm="gc -m"
alias gca="gc --amend --no-edit"
alias gcam="gc --amend"
alias gu="git push"
alias gut="gu --tags"
alias guf="gu -f"
alias gl="git pull"
alias gls="gl --rebase"
alias glo="gl origin"
alias gs="git rebase"
alias gsi="gs -i"
alias gss="gs --skip"
alias gsc="gs --continue"
alias gsa="gs --abort"
# alias gh="git checkout" # conflicts with github-cli
alias gco="git checkout"
alias ge="git merge"
alias gea="ge --abort"
alias gr="git remote"
alias gb="git branch"
alias gbu="git branch --set-upstream-to "
alias gt="git tag"
alias gf="git fetch"
alias gg="git log"
alias ggs="git log --stat"
alias ggso="git log --stat --oneline"
alias ggo="git log --oneline"
alias ggg="git log --oneline --all --graph --decorate"
alias gk="git cherry-pick"
alias gw="git show"
alias gw^="gw HEAD^"
alias gw^^="gw HEAD~2"
alias gw^^^="gw HEAD~3"
alias gw^^^^="gw HEAD~4"
alias gfg="git config --global"
alias gc_counts="git shortlog -s | sort -k1 -nr"
alias gc_total="git rev-list --all --count"

# `git commit -m` with date
# Accepted formats: "YYYY.MM.DD", "MM/DD/YYYY", "DD.MM.YYYY", RFC 2822 and ISO 8601
# See https://alexpeattie.com/blog/working-with-dates-in-git
tgcm() {
    local date=$1
    shift
    GIT_AUTHOR_DATE="$date" GIT_COMMITTER_DATE="$date" gcm "$@" --date "$date"
}

# NPM
alias nu="npm update"
alias ni="npm install"
alias ns="npm run --silent"
alias np="npm publish"
alias npp="npm publish --access=public"

# Composer
alias cu="composer update"
alias ci="composer install"
alias cr="composer require"
alias cs="composer run-script"

# Docker
alias dv="docker ps"
alias dva="docker ps -a"
alias dn="docker run"
alias de="docker exec"
alias dei="docker exec -it"
alias ds="docker start"
alias dr="docker restart"
alias dt="docker stop"
alias dta="docker stop \$(docker ps -qa)"
alias dp="docker system prune -a"
alias dvrmd="docker volume rm \$(docker volume ls -f dangling=true -q)"
alias drm="docker rm"
alias drme="docker rm \$(docker ps -qa --no-trunc --filter 'status=exited')"
alias db="docker build"
alias dbt="docker build -t"

# Run a clean bash container with current folder mounted as /srv
alias dbash='docker run --rm -it -v "$(pwd):/srv" -w /srv bash'

# docker-compose
alias dcs="docker-compose -p \$(pwd | sed 's#[/.]#-#g; s/^-//g')"
alias dcsb="dcs build"
alias dcsu="dcs up -d"
alias dcsd="dcs down"

# Kubernetes
alias kva="kubectl get all"
alias kvp="kubectl get pod"
alias kvs="kubectl get service"
alias kvd="kubectl get deployment"
alias kvr="kubectl get replicaset"
alias kn="kubectl run"
alias ke="kubectl exec"
alias kei="kubectl exec -it"
alias kl="kubectl logs"

# ------------------------------------------------------------------------------
## shortcut  for iptables and pass it via sudo#
alias ipt='sudo /sbin/iptables'

# display all rules #
alias iptlist='sudo /sbin/iptables -L -n -v --line-numbers'
alias iptlistin='sudo /sbin/iptables -L INPUT -n -v --line-numbers'
alias iptlistout='sudo /sbin/iptables -L OUTPUT -n -v --line-numbers'
alias iptlistfw='sudo /sbin/iptables -L FORWARD -n -v --line-numbers'
alias firewall=iptlist

# ------------------------------------------------------------------------------
command -v colordiff > /dev/null && alias diff='colordiff'

# Resume wget by default
command -v wget > /dev/null && alias wget='wget -c'

# ------------------------------------------------------------------------------
# Reload the shell (i.e. invoke as a login shell)
alias reload_shell="exec \${SHELL}"
alias reload="exec \"\$(realpath /proc/\$\$/exe)\" || exec \${SHELL}"

# Print each PATH entry on a separate line
alias path='echo -e ${PATH//:/\\n}'

# ------------------------------------------------------------------------------
# get error messages from journalctl
alias jctl="journalctl -p 3 -xb"

# ------------------------------------------------------------------------------
# youtube-dl
alias yta-aac="youtube-dl --extract-audio --audio-format aac "
alias yta-best="youtube-dl --extract-audio --audio-format best "
alias yta-flac="youtube-dl --extract-audio --audio-format flac "
alias yta-m4a="youtube-dl --extract-audio --audio-format m4a "
alias yta-mp3="youtube-dl --extract-audio --audio-format mp3 "
alias yta-opus="youtube-dl --extract-audio --audio-format opus "
alias yta-vorbis="youtube-dl --extract-audio --audio-format vorbis "
alias yta-wav="youtube-dl --extract-audio --audio-format wav "
alias ytv-best="youtube-dl -f bestvideo+bestaudio "


# ------------------------------------------------------------------------------
is_path() {
    local p
    p="${1%/}"
    [ -z "$p" ] && p="$1"
    sed 's/:/\n/g' <<<"$PATH" | grep -q "^$p/*\$"
}

add_path() {
    ! is_path "$1" && [ -d "$1" ] && export PATH="$1:$PATH"
}
path_add() {
    ! is_path "$1" && [ -d "$1" ] && export PATH="$PATH:$1"
}

del_path() {
    local p
    p="${1%/}"
    [ -z "$p" ] && p="$1"
    if is_path "$p";
    then
        export PATH;
        PATH=$(sed 's/:/\n/g' <<<"$PATH" | grep -v "^$p/*\$" | sed '{ :q;N;s/\n/:/g;t q }')
    fi
}

# Test whether a glob has any matches
# https://stackoverflow.com/questions/2937407/test-whether-a-glob-has-any-matches-in-bash
exists() {
    # Bash
    if command -v compgen > /dev/null
    then
        compgen -G "$1" > /dev/null
        return $?
    fi

    # Exceptions
    case "$(shelltype)" in
        zsh)
            local f=$1
            if [ -e "$f" ] || [ -L "$f" ]; then return 0; fi

            # If $1 is a pattern, we have to expand it in zsh:
            local g
            g=$(setopt | grep nullglob)
            setopt nullglob
            set -- ${~f} 2> /dev/null
            [ -z "$g" ] && setopt +o nullglob
            [ "$f" = "$1" ] && return 1
            [ -e "$1" ] || [ -L "$1" ]
            return $?
        ;;
        # *) ;;
    esac

    # Non-Bash
    for f in $1; do
        ## Check if the glob gets expanded to existing files.
        ## If not, f here will be exactly the pattern above
        ## and the exists test will evaluate to false.
        [ -e "$f" ] || [ -L "$f" ]

        ## This is all we needed to know, so we can break after the first iteration
        return $?
    done
}

alias nowtime='date +"%T"'
alias nowdate='date +"%d-%m-%Y"'

# Stop after sending count ECHO_REQUEST packets #
alias ping='ping -c 5'

alias netports="netstat -tulapn"

# grep process:
alias psgrep='ps aux | head -n1; ps aux | grep -v "\bgrep\b" | grep -i'

# Wait for a process to end by its PID
wait_pid() {
    local pid=$1
    local interval="${2:-1}"
    while kill -0 "$pid" &> /dev/null; do sleep "$interval"; done
}

# Wait for a process to end by its name/path
wait_proc() {
    local pid
    pid=$(pidof "$1") || return $?
    shift
    echo "PID $pid"
    wait_pid "$pid" "$@"
}

## Get cpu info ##
if command -v lscpu > /dev/null;
then
    alias cpuinfo='lscpu'
else
    alias cpuinfo='less /proc/cpuinfo'
fi

alias cpucount='getconf _NPROCESSORS_ONLN'


# psmem [-g grep] [-u user] ... [-c] command
# @author DUzun.Me
psmem() {
    local help
    local cmd
    local user
    local grep
    local POSITIONAL=()

    # Parse parameters
    while [ $# -gt 0 ]; do
        local key="$1"

        case $key in
            -g|--grep)
                grep="$2"
                shift # past argument
                shift # past value
            ;;
            -u|--user)
                user="$2"
                shift # past argument
                shift # past value
            ;;
            -c|-C|--cmd)
                cmd="$2"
                shift # past argument
                shift # past value
            ;;
            --help)
                help=1
            ;;
            *)    # unknown option
                POSITIONAL+=("$1") # save it in an array for later
                shift # past argument
            ;;
        esac
    done

    set -- "${POSITIONAL[@]}" # restore positional parameters

    if [ -z "$cmd" ] && [ $# -gt 0 ]; then
        cmd="$1"
        shift
    fi

    local h=rss
    local a="$*"
    local e=

    # Show usage/help
    if [ -z "$cmd" ] && [ -z "$grep" ] && [ -z "$user" ] && [ -z "$a" ] || [ -n "$help" ]; then
        echo "Usage:"
        echo "   psmem [-g grep] [-u user] ... [-c] command"
        echo "   psmem --help"
        echo ""
        echo "   All extra parameters go to \`ps\`"
        return 1
    fi

    if [ -n "$user" ]; then
        a="$a -A"
        h="user,$h"
        e="$e | awk '\$1 == \"$user\"' | cut -d' ' -f1 -s --complement"
        if [ -n "$cmd" ]; then
            h="$h,comm"
            e="$e | awk '\$2 == \"$cmd\"'"
        else
            [ -n "$grep" ] && h="$h,comm"
        fi
    else
        if [ -n "$cmd" ]; then
            a="$a -C '$cmd'"
        else
            a="$a -A"
        fi
        [ -n "$grep" ] && h="$h,comm"
    fi

    local e="ps --no-headers -o '$h' $a$e"
    [ -n "$grep" ] && e="$e | grep -v grep | grep -i '$grep'"
    if [ "$h" != "rss" ]; then
        cmd=$(eval "$e" | awk '{print $2}' | sort | uniq -c | sort -k1 -nr | awk '{print "("$2" x"$1")"}')
        e="$e | awk '{print \$1}'"
    else
        cmd=;
    fi

    echo -n "${cmd[@]}" "RAM: "
    a=$(eval "$e")
    h=$(echo "${a[@]}" | wc -w)
    if [ "$h" -gt 0 ]; then
        echo -n "$( ( IFS=$'\n'; echo "${a[@]}" ) | awk '{ sum+=$1 } END { printf ("%s%d%s", "~", sum/NR/1024,"M") }') x$h = "
        ( IFS=$'\n'; echo "${a[@]}" ) | awk '{ sum+=$1 } END { printf ("%d%s", sum/1024,"M") }'
    else
        echo none
    fi
}

# @author DUzun.Me
psmemo() {
    local p=$1
    local g=$2
    local h=rss # comm
    local c
    [ -n "$g" ] && h=$h,user

    list() {
        if [ -z "$g" ]; then
            ps --no-headers -o "$h" -C $p
        else
            ps --no-headers -o "$h" -C $p | grep $g
        fi
    }

    c=$(list | wc -l)
    echo -n "\"$1"\" "RAM: "
    if [ "$c" -gt 0 ]; then
        echo -n "$(list | awk '{ sum+=$1 } END { printf ("%s%d%s", "~", sum/NR/1024,"M") }') x$c = "
        list | awk '{ sum+=$1 } END { printf ("%d%s", sum/1024,"M") }'
    else
        echo none
    fi
}

# Import an /etc/passw line
# Eg. `impw 'duzun:x:1000:1000:Dumitru Uzun,,,,duzun.me:/home/duzun:/bin/bash'`
impw() {
    local login=$(echo "$1" | cut -d: -f1)
    local uid=$(echo "$1" | cut -d: -f3)
    local gid=$(echo "$1" | cut -d: -f4)
    local comment=$(echo "$1" | cut -d: -f5)
    local home=$(echo "$1" | cut -d: -f6)
    local shell=$(echo "$1" | cut -d: -f7)
    shift

    useradd -u "$uid" -g "$gid" -d "$home" -s "$shell" -c "$comment" "$@" "$login"
}

# ------------------------------------------------------------------------------
alias root="sudo -i"
command -v su > /dev/null || alias su="sudo -i"

# reboot / halt / poweroff
if [ "$UID" != "0" ]; then
    alias reboot > /dev/null 2>&1 || alias reboot='sudo /sbin/reboot'
    alias poweroff='sudo /sbin/poweroff'
    alias halt='sudo /sbin/halt'
    alias shutdown='sudo /sbin/shutdown'

    command -v compsize > /dev/null && alias compsize="sudo compsize"
fi

# ------------------------------------------------------------------------------
# This alias recursively destroys all .DS_Store files in the folder I am currently in
alias killDS="find . -type f -name '*.DS_Store' -ls -delete"

# Canonical hex dump; some systems have this symlinked
command -v hd > /dev/null || alias hd="hexdump -C"

# macOS has no `md5sum`, so use `md5` as a fallback
command -v md5sum > /dev/null || alias md5sum="md5"

# macOS has no `sha1sum`, so use `shasum` as a fallback
command -v sha1sum > /dev/null || alias sha1sum="shasum"

# Generate sha1 digest
alias sha1="openssl sha1 | cut -d' ' -f2"

# Start calculator with math support
alias bc='bc -l'

# ------------------------------------------------------------------------------
#alias ..="cd .."

# $ .. [nr]
# @author DUzun.Me
..() {
    local LASTDIR=$PWD
    local i=$1
    [ $# -eq 0 ] && i=1
    while [ $i -gt 0 ] && [ "$PWD" != "/" ]
    do
        cd ..
        i=$((i - 1))
    done
    export OLDPWD=$LASTDIR
    return $i
}

alias ...='cd ../..'
alias ....='cd ../../..'

# cd up to "partial_str"
# $ up "partial_str"
up() {
    local up;
    up=$(expr "$PWD" : "^\(.*$1[^/]*\)")
    [ "x$up" = "x" ] || cd "$up" || return 1
}

# Create directory and cd to it
mcd() {
    mkdir -p "$@" && cd "$_" || return $?
}

# Short for <find file>
f() {
    find "$PWD" -type 'f' -name "$@"
}

# Get common part of two string at the beginning
str_common_part() {
    local s="$1"
    local t="$2"
    local l=1
    local n=${#s}

    while [ "${t#${s:0:$l}}" != "$t" ] && [ "$l" -lt $(( n + 1 )) ]; do
        (( l = l + 1 ))
    done
    (( l = l - 1 ))

    echo "${s:0:$l}"

    if [ "$l" -eq 0 ]; then return 1; fi
}

# Normalize a path string
normpath() {
    # local ret="${1//\/\.\//\/}"
    local ret="$1"
    ret=$(echo "$ret" | sed -r 's#/\./#/#g')
    ret=$(echo "$ret" | sed -r 's#/\.$##g' )
    ret=$(echo "$ret" | sed -r 's#^\./##g')
    ret=$(echo "$ret" | sed -r 's#[^\./]+/\.\.(/|$)##g')
    # @TODO: /path/with/.dot/../or./../or.eve.in.the.middle/.. -> /path/with/

    echo "$ret";
}

# Returns relative path from $1/$source to $2/$target
relpath() {
    local source target common_part ret

    source=$(normpath "$1")
    target=$(normpath "$2")

    if [ "${source: -1}" != "/" ]; then source="$source/"; fi

    common_part=$(str_common_part "$source" "$target")

    if [ -z "$common_part" ]; then
        echo "$target";
        return 1;
    fi

    if [ "${common_part: -1}" != "/" ]; then common_part="${common_part%/*}/"; fi

    ret=$(sed -r 's#[^\/]+\/#../#g' <<< "${source:${#common_part}}")
    echo "$ret${target:${#common_part}}";
}


# One of @janmoesen’s ProTip™s
for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
    alias "${method}"="lwp-request -m '${method}'"
done

# cURL with Cookies
alias ccurl="curl -b /tmp/cookie_curl.txt -c /tmp/cookie_curl.txt"
alias ccurl_edit="command \${EDITOR_PATH:-\$EDITOR} /tmp/cookie_curl.txt"

# Download first argument to stdout
if command -v curl > /dev/null; then
    alias download="curl -sS"
elif command -v wget > /dev/null; then
    alias download="wget -qO-"
## Could use GET alias defined above, but it doesn't support HTTPS by default
# else
#     alias download="GET"
fi;

# Download from FTP
if command -v wget > /dev/null; then
    # --ftp-user=<ftp_user> --ftp-password=<ftp_pwd>
    alias downftp="wget -qr -nH -m"
fi;

# Intuitive map function
# For example, to list all directories that contain a certain file:
# find . -name .gitattributes | map dirname
alias map="xargs -n1"

# diff two binary files
diffbin() {
    cmp -l "$1" "$2" | gawk '{printf "%08X %02X %02X\n", $1-1, strtonum(0$2), strtonum(0$3)}'
}

# bin2hex pipe
alias bin2hex="hexdump -v -e '1/1 \"%02x\"'"

# randhex $byte_length
randhex() {
    head -c${1:-32} /dev/urandom | hexdump -v -e '1/1 "%02x"'
}

# randtext $byte_length
randtext() {
    head -c${1:-32} /dev/urandom | base64 | tr -d '=' | tr '+/' '-_'
}

# ------------------------------------------------------------------------------
# Make sure there is the `code` command, even when only vscodium is installed
if command -v vscodium > /dev/null && ! command -v code > /dev/null; then
    alias code="vscodium"
fi

# Open editor (no wait)
edit() {
    if [ -f "$EDITOR_PATH" ]; then
        command "$EDITOR_PATH" $EDITOR_ARGS "$@";
    else
        echo "Editor not found (\$EDITOR_PATH='$EDITOR_PATH')";
        return 255;
    fi;
}

# Overwrite contents and then remove file
overdel() {
    p="$(realpath "$1")"
    find "$p" -type 'f' | while read -r i; do
        # s=`du -sb "$i" | head -1 | awk '{print $1}'`;
        s=$(wc -c < "$i");
        echo "$s > $i";
        head -c "$s" < /dev/urandom > "$i";
        rm -rf -- "$i";
    done;
}

_rm_dir_ask() {
    local dir=$1
    local forced=$2
    if [ -z "$dir" ]; then
        >&2 echo "No folder path provided"
        return 1
    fi

    if [ ! -d "$dir" ]; then
        >&2 echo "Folder not found: $dir"
        return 2
    fi

    if [ -z "$forced" ]; then
        echo "Are you sure you want to delete all files in $dir?"
        read -p " [Y/n]" -n 1 -r;
        echo "";
        if [[ ! "${REPLY:-Y}" =~ ^[Yy]$ ]]; then
            return 10;
        fi
    fi
}

rm_all() {
    local forced
    if [ "$1" = "-f" ]; then
        forced=1
        shift
    fi

    [ "$1" == "--" ] && shift

    local dir=$1
    _rm_dir_ask "$dir" "$forced"

    case $? in
        1)
            >&2 echo "  rm_all [-f] <dir_name>"
            return 1
        ;;
        0) ;;
        *) return $?;;
    esac;

    # ( cd "$dir" && perl -e 'for(<*>){unlink}' ) # this is not recursive
    # find "$dir" -type f -exec ionice -c3 rm {} + # this does not remove subfolders
    mkdir -p /tmp/_rm_all_empty && rsync -a --delete /tmp/_rm_all_empty/ "$dir/" && rm -rf /tmp/_rm_all_empty # this might be faster, uses more CPU, requires an extra step of creating an empty folder
}

rm_all_slow() {
    local forced
    if [ "$1" = "-f" ]; then
        forced=1
        shift
    fi

    [ "$1" == "--" ] && shift

    local dir=$1
    _rm_dir_ask "$dir" "$forced"

    case $? in
        1)
            >&2 echo "  rm_all [-f] <dir_name>"
            return 1
        ;;
        0) ;;
        *) return $?;;
    esac;

    # find "${dir:?}" -type f -exec ionice -c3 rm {} + # this is faster, but also may yield high CPU
    find "${dir:?}" -type f -exec ionice -c3 rm {} \; && \
    rm -rf -- "${dir:?}"/*
}

# broot
alias br='broot -dhp'
alias bs='broot --sizes'

# Determine size of a file or total size of a directory
fs() {
    if [ "$1" = "--help" ]; then
        cat << EOH
Usage: fs [-s | -h [-<number>]] [-<du_options>] [<path> | <glob>]
Determine size of a file or total size of a directory

Options:
    -s, --sort    Sort results by size
    -h, --head    Show only first results, sorted by size

You can also pass any \`du\` options before the <path> | <glob>,
except '-sh', which are set anyways.

Example:
    fs
        List file sizes for all files and folders in current folder
    fs -s
        List file sizes for all files and folders in current folder, sorted by size
    fs -h -7
        List top 7 files and folders in current folder, sorted by size
    fs /var/log/nginx
        Folder size
    fs -- /var/log/nginx/*
        List file sizes for all non-hidden files and folders in /var/log/nginx/
    fs -x /tmp/
        Folder size, skip directories on different file systems (see \`du --help\`)
EOH
        return 0
    fi

    if [ "$1" = "-s" ] || [ "$1" = "--sort" ]; then
        shift
        # Detect --human sort support
        if sort --help | grep -- '--human' > /dev/null; then
            fs "$@" | sort -rh
        else
            fs "$@" | sort -rn
        fi
        return $?
    fi

    local arg
    if [ "$1" = "-h" ] || [ "$1" = "--head" ] || [ "$1" = "--top" ]; then
        shift
        # -<number> arguments go to `head`, except '-0'
        if [ "${1:0:1}" = "-" ] && (( -$1 > 0 )); then
            arg="$1"
            shift
        fi
        fs -s "$@" | head $arg
        return $?
    fi

    # Detect --apparent-size support of `du`
    if du -b --exclude='*' /dev/null > /dev/null 2>&1; then
        arg=-sbh;
    else
        arg=-sh;
    fi

    # Gather du options
    while [ "${1:0:1}" = "-" ] && [ "$1" != "--" ]; do
        arg="$arg $1"
        shift
    done
    [ "$1" = "--" ] && shift

    # We need a files list separator --
    arg="$arg --"

    # If no files arguments, assume all files in current folder
    if [ $# -eq 0 ]; then
        exists '.[^.]*' && arg="$arg .[^.]*"
        exists '*' && arg="$arg *"
    fi

    # `eval` used just for the sake of zsh, but an unwanted side-effect:
    # `fs -- '*'` is the same as `fs -- *`, but it shouldn't!
    eval "du $arg" "$@";
}

command -v filesize > /dev/null || alias filesize="wc -c <"

# File age (since last modification)
filemage() {
    local fm ts
    ts=$(date "+%s")
    if ! fm=$(stat -c '%Y' "$1" 2> /dev/null) || [ -z "$fm" ]; then return 1; fi

    echo $(( ts - fm ))
}

# Convert a number to memory unit (K, M, G)
mem_unit() {
    local sum=${1:-$(cat)}
    local unit=B
    if [ "$sum" -gt 1024 ]; then
        sum=$(( sum / 1024 ))
        unit=K
        if [ $sum -gt 1024 ]; then
            sum=$(( sum / 1024 ))
            unit=M
            if [ $sum -gt 1024 ]; then
                sum=$(( sum / 1024 ))
                unit=G
            fi
        fi
    fi
    echo "$sum$unit"
}

# ------------------------------------------------------------------------------
#
# # ex - archive extractor
# # usage: ex <file>
ex() {
  if [ -f "$1" ] ; then
    case $1 in
      *.tar.bz2)   tar xjf "$1"   ;;
      *.tar.gz)    tar xzf "$1"   ;;
      *.tar.xz)    tar xJf "$1"   ;;
      *.tar.zst)   unzstd "$1"    ;;
      *.tar)       tar xf "$1"    ;;
      *.tbz2)      tar xjf "$1"   ;;
      *.tgz)       tar xzf "$1"   ;;
      *.bz2)
            if command -v pbzip2 > /dev/null;
            then pbzip2 -k -d "$1";
            else bunzip2 -k -d "$1";
            fi
        ;;
      *.gz)
            if command -v pigz > /dev/null;
            then pigz -k -d "$1"
            else gunzip -k -d "$1"
            fi
        ;;
      *.rar)       unrar x "$1"   ;;
      *.zip)       unzip -o "$1"  ;;
      *.Z)         uncompress "$1";;
      *.7z)        7z x "$1"      ;;
       *.deb)      ar x "$1"      ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    >&2 echo "'$1' is not a valid file"
  fi
}
# ------------------------------------------------------------------------------
# translit "стринг"
# echo "текст" | translit
# translit <<< "стдин"
translit() {
    local NAME=${*:-$(cat)};
    local TRS;
    TRS=$(sed "y/абвгдезийклмнопрстуфхцы/abvgdezijklmnoprstufxcy/" <<< "$NAME")
    TRS=$(sed "y/АБВГДЕЗИЙКЛМНОПРСТУФХЦЫ/ABVGDEZIJKLMNOPRSTUFXCY/" <<< "$TRS")
    TRS=${TRS//ч/ch};
    TRS=${TRS//Ч/CH} TRS=${TRS//ш/sh};
    TRS=${TRS//Ш/SH} TRS=${TRS//ё/jo};
    TRS=${TRS//Ё/JO} TRS=${TRS//ж/zh};
    TRS=${TRS//Ж/ZH} TRS=${TRS//щ/sh\'};
    TRS=${TRS///SH\'} TRS=${TRS//э/je};
    TRS=${TRS//Э/JE} TRS=${TRS//ю/ju};
    TRS=${TRS//Ю/JU} TRS=${TRS//я/ja};
    TRS=${TRS//Я/JA} TRS=${TRS//ъ/\`};
    TRS=${TRS//ъ\`} TRS=${TRS//ь/\'};
    TRS=${TRS//Ь/\'}
    command -v iconv > /dev/null && TRS=$(iconv -c -f UTF8 -t ASCII//TRANSLIT <<< "$TRS")
    echo "$TRS";
}

# ------------------------------------------------------------------------------
lowercase() {
    # echo "$1" | sed "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/" # ACII only
    # echo "${@,,}" # bash
    echo "${@:-$(cat)}" | awk '{print tolower($0)}'
}

# ------------------------------------------------------------------------------
# Strip whitespace (or other characters) from the beginning and end of a string
# eg. echo "  x " | trim          -> "x"
# eg. echo "..x." | trim '.'      -> "x"
# eg. echo ".,x.," | trim '.' ',' -> ",x."
trim() {
    local l r
    if [ $# -eq 0 ]; then
        sed -r 's/^[[:space:]]*//g; s/[[:space:]]*$//g'
    else
        l=${1}
        r=${2:-$1}
        sed -r "s/^[$l]*//g; s/[$r]*\$//g"
    fi
}

# ------------------------------------------------------------------------------
# open-url some-file-from-windows.url
open-url() {
    if [ $# -eq 0 ]; then
        echo "open-url <path/to/file.url>"
        return 1;
    fi

    _url="${1}"
    _u=$(grep '^URL=' "$_url")

    if [ -z "$_u" ]; then
        echo "open-url: Wrong file format"
        return 2
    fi

    _u="${_u:4}"

    for i in 'open' xdg-open google-chrome google-chrome-stable firefox;
    do
        if command -v "$i" > /dev/null; then
            _o="$i";
            break;
        fi
    done

    eval "$_o '$_u'"
}
# ------------------------------------------------------------------------------
# Convert a git remote to corresponding HTTP(S) URL
# Example: git@github.com:duzun/dotfiles.git -> https://git@github.com/duzun/dotfiles
git2url() {
    local url="${1:-$(cat)}"

    case $url in
        *://*) ;;
        *@*:*)
            url="${url%.git}"
            url="${url#*@}"
            url="$(sed 's/:/\//' <<<"$url")"
            url="${2:-https}://${url}"
        ;;
    esac
    echo "$url"
}

# ------------------------------------------------------------------------------

abs_url() {
    local url=$1
    local base=${2%*/}
    case $url in
        http://*|https://*|ftp://*|file:///*)
            echo "$url"
        ;;
        //*) echo "${base%*://*}:$url" ;;
        # /*) echo "${base%*://*}:$url" ;;
        *) echo "$(dirname "$base")/$url" ;;
    esac
}

# ------------------------------------------------------------------------------
localip() {
    ip route show | grep -v linkdown | grep -v 'br-' | awk -F'src ' '/src/ { print $2 }' | tail -1 | cut -d' ' -f1
}

# ------------------------------------------------------------------------------
# Create a data URL from a file
dataurl() {
    local mimeType;
    mimeType=$(file -b --mime-type "$1");
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8";
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# ------------------------------------------------------------------------------
# Show all the names (CNs and SANs) listed in the SSL certificate for a given domain
getcertnames() {
    local tmp;
    local domain=${1:-$(hostname)};
    if [ -z "$domain" ]; then
        echo "ERROR: No domain specified.";
        return 1;
    fi;

    echo "Testing ${domain}…";
    echo ""; # newline

    tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
        | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

    if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText;
        certText=$(echo "${tmp}" \
            | openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
            no_serial, no_sigdump, no_signame, no_validity, no_version");
        echo "Common Name:";
        echo ""; # newline
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
        echo ""; # newline
        echo "Subject Alternative Name(s):";
        echo ""; # newline
        echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
            | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
        return 0;
    else
        echo "ERROR: Certificate not found.";
        return 1;
    fi;
}

# ------------------------------------------------------------------------------
# https://stackoverflow.com/a/38463476/1242333
getspfranges() {
    domainsToDig=$(dig @8.8.8.8 "_spf.$1" TXT +short | \
    sed \
        -e 's/"v=spf1//' \
        -e 's/ ~all"//' \
        -e 's/ include:/\n/g' | \
    tail -n+2)
    for domain in $domainsToDig ; do
        dig @8.8.8.8 "$domain" TXT +short | \
            sed \
                -e 's/"v=spf1//' \
                -e 's/ ~all"//' \
                -e 's/ ip.:/\n/g' | \
            tail -n+2
    done
}

# Get Googles' IPs
getgoogleranges() {
    getspfranges google.com
}

# ------------------------------------------------------------------------------
# Show the map
alias mapscii="telnet mapscii.me"

# ------------------------------------------------------------------------------
# syncthing rename: Rename files restored from .stversion
strename() {
    o=$(realpath -- "$1")
    d=$(dirname "$o")
    b=$(basename "$o")
    n=$(echo "$b" | sed -r 's/^(.+)\~[0-9]{8,8}\-[0-9]{6,6}(\..+)?/\1\2/; s/^\~[0-9]{8,8}\-[0-9]{6,6}(\..+)/\1/');

    if [ -d "$o" ]; then
        ( shopt -s dotglob && cd "$o" && for i in *; do strename "$i"; done; );
    fi;

    if [[ "$n" != "$b" ]]; then
        echo "$d: $b -> $n";
        mv -- "$o" "$d/$n";
    fi;
}

# ------------------------------------------------------------------------------
# Expand an alias recursively, and echoes the arguments unchanged if not an alias
#   Eg. alias_expand <alias> [<arguments>]
#
#   NOTE: Is it possible to use readline's shell-expand-line or alias-expand-line?
alias_expand() {
    local a c
    c="$1"
    if a=$(alias "$c" 2> /dev/null); then
        a=$(echo "$a" | sed 's/^alias .*='\''//;s/'\''$//')
        shift
        set -- $a "$@"
        if [ "$c" == "$1" ]; then
            echo "$@"
        else
            alias_expand "$@"
        fi
    else
        echo "$@"
        return 1
    fi
}

alias_cmd() {
    alias_expand "$1" | cut -d' ' -f1
}

alias_subcmd() {
    alias_expand "$1" | cut -d' ' -f2
}

alias_completion() {
    # keep global namespace clean
    local cmd completion

    # determine first word of alias definition
    cmd=${2:-$(alias_cmd "$1")}

    # determine completion function
    completion=$(complete -p "$1" 2>/dev/null)

    # run _completion_loader only if necessary
    [[ -n $completion ]] || {

        # load completion
        command -v _completion_loader > /dev/null && \
        _completion_loader "$cmd"

        # detect completion
        completion=$(complete -p "$cmd" 2>/dev/null)
    }

    # ensure completion was detected
    [[ -n $completion ]] || return 1

    # configure completion
    eval "$(sed "s/$cmd\$/$1/" <<<"$completion")"
}

_source_completion_loader() {
    command -v complete > /dev/null || return 1;

    local _f _c

    if ! command -v _completion_loader > /dev/null;
    then
        # Is bash-completion installed?
        _f=/usr/share/bash-completion/bash_completion
        [ -f "$_f" ] && . "$_f"
    fi

    # complete-alias requires bash-completion
    if command -v _completion_loader > /dev/null && \
     ! command -v _complete_alias > /dev/null;
    then
        _c="$_dotfiles/../complete-alias"
        # _f="$_c/bash_completion.sh" # old path
        _f="$_c/complete_alias"
        if [ ! -f "$_f" ] && command -v git > /dev/null; then
            if [ -e "$_c/.git" ]; then (
                cd "$_c" && \
                git checkout -f . && \
                git pull --rebase
            )
            else (
                cd "$_dotfiles/.." && \
                git submodule init && \
                git submodule update
            )
            fi
        fi

        [ -f "$_f" ] && . "$_f"
    fi
}

_init_complete() {
    command -v complete > /dev/null || return 1;

    _source_completion_loader;

    if command -v _completion_loader > /dev/null;
    then
        _completion_loader git
        _completion_loader curl
    fi

    # alias_completion g;
    _ga=( \
        gv gva gvs \
        ga gap gaa \
        gc gcm gca gcam \
        gd gda gdao gdan \
        gb gbu \
        gu gut guf \
        gl gls glo \
        gco \
        gk \
        gs gsi gss gsc gsa \
        gr \
        gg ggo  \
        ge gea \
        gt gf gfg \
        gw gw^ \
    );

    # Enable completion for aliases
    if command -v __git_complete > /dev/null;
    then
        for a in "${_ga[@]}"; do __git_complete "$a" "_git_$(alias_subcmd "$a" | tr -s '-' '_')"; done
    else
        for a in "${_ga[@]}"; do complete -o default -o nospace -F "_git_$(alias_subcmd "$a" | tr -s '-' '_')" "$a"; done
    fi

    unset _ga

    # if complete-alias is loaded, use it for some aliases
    if command -v _complete_alias > /dev/null;
    then
        _a=( \
            # git
            g \

            dfh du1 du0 \

            # npm
            nu ni ns np npp \

            # docker
            dv dva dn de dei ds dr dt drm db dbt \

            # docker-compose
            dcs dcsb dcsu dcsd \

            ccurl \
        );

        for a in "${_a[@]}"; do complete -F _complete_alias "$a"; done
        unset _a
    fi

    alias_completion mcd mkdir
    # alias_completion ccurl
}

# ------------------------------------------------------------------------------
# Add to path npm's bin folder
npmbin() {
    local npmbin;
    npmbin=${PWD:-$(pwd)}/node_modules/.bin;
    add_path "$npmbin" && echo "$npmbin";
    return $?;
}


# Add to path composer's bin folder
composerbin() {
    local composerbin;

    # Global
    composerbin=~/.composer/vendor/bin;
    add_path "$composerbin" # && echo "$composerbin";

    # Local
    composerbin=${PWD:-$(pwd)}/vendor/bin;
    add_path "$composerbin" && echo "$composerbin";
    return $?;
}

# ------------------------------------------------------------------------------
_is_sourced() {
    _is_sourced="$1"
    local _rc="$2"

    grep -q "^[^#]*. $_is_sourced"          "$_rc" || \
    grep -q "^[^#]*source $_is_sourced"     "$_rc" || \
    grep -q "^[^#]*. '$_is_sourced'"        "$_rc" || \
    grep -q "^[^#]*source '$_is_sourced'"   "$_rc" || \
    grep -q "^[^#]*. \"$_is_sourced\""      "$_rc" || \
    grep -q "^[^#]*source \"$_is_sourced\"" "$_rc" && \
    return

    _is_sourced=
    return 1
}

is_sourced() {
    local fn="$1"
    local _rc="$2"

    if [ -z "$_rc" ]; then
        _shell=$(shelltype)
        _rc=~/".${_shell}rc";
    fi

    [ -e "$_rc" ] || return 2

    local _dn _fn
    _dn="$(dirname "$fn")"
    if  [ "$_dn" = "~" ] || \
        [ "$_dn" = "\$HOME" ] || \
        [ "$_dn" = "$HOME" ]
    then
        _fn="$(basename "$fn")"
        _is_sourced      "~/$_fn" "$_rc" || \
        _is_sourced "\$HOME/$_fn" "$_rc" || \
        _is_sourced  "$HOME/$_fn" "$_rc" || \
        return 1
    else
        _is_sourced "$fn" "$_rc" || return 1
    fi
}

is_dotfiles_sourced() {
    local _rc="$1"
    local fn=~/.source

    if [ -z "$_rc" ]; then
        _shell=$(shelltype)
        _rc=~/".${_shell}rc";
    fi

    [ "$(readlink "$fn")" = "$_dotfiles/source" ] && is_sourced '~/.source' "$_rc"  || \
    is_sourced "$_dotfiles/source" "$_rc" || \
    is_sourced "\$_dotfiles/source" "$_rc" || \
    return 1
}

# ------------------------------------------------------------------------------
# Init git config.
# Usage: init_git [-f]
init_git() {
    if ! command -v git > /dev/null ; then
        echo "Looks like git is not installed"
        return 1
    fi

    # [ -n "$BASH" ] && ! command -v __git_ps1 > /dev/null && [ ! -e ~/.git-prompt.sh ] && \
    # curl -L -o ~/.git-prompt.sh https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh

    local _name _value _default _section _username _pv _dvb
    local gfg="git config --global"

    _force=$(echo "$@" | grep -- '-f')
    grep -v '^;' "$_dotfiles/.gitconfig" | while read -r ln; do
        ln="${ln##*( )}"
        if [[ "${ln:0:1}" == "[" ]]; then
            ln=$(echo "${ln:1:${#ln}-2}" | tr -s '\ "' '.')
            _section=${ln%%.}
            # echo [$_section]
        else
            _name=${ln%%=*}
            _value=${ln:${#_name}+1}
            _value=${_value/# /}
            _name=${_name/% /}
            # echo $_section.$_name=$_value
            $gfg "$_section.$_name" "$_value"
        fi
    done

    echo ""
    echo "$gfg:"
    _section=user
    _username=$(whoami)
    _value=
    for _name in name email username; do
        _pv=$_value
        _value=$($gfg "$_section.$_name");
        _default=$_value;

        # Try to get a default value for missing git config
        if [ -z "$_default" ] ; then
            if [[ "$_name" == "name" ]]; then
                _default=$(getent passwd "$_username" | cut -d: -f5 | cut -d, -f1)
            elif [[ "$_name" == "email" ]]; then
                _default="$_username@$(hostname)"
            elif [[ "$_name" == "username" ]]; then
                _default=$_username
                if [[ "$_default" == "root" ]] || [[ "$_default" == "user" ]]; then
                    if [ -n "$_pv" ]; then
                        _default=${_pv%%\@*}
                    fi
                fi
            fi
        fi

        _dvb=" ($_default)";
        [ -z "$_default" ] && _dvb=;

        if [ -z "$_value" ] || [ -n "$_force" ] ; then
            read -r -p "    $_section.$_name$_dvb:" v;
            [ -z "$v" ] && [ -n "$_default" ] && v=$_default
            if [ -n "$v" ]; then
                $gfg "$_section.$_name" "$v";
                _value=$v;
            fi
        else
            echo "    $_section.$_name: $_value";
        fi
    done

    _name=credential.helper
    $gfg $_name > /dev/null
    if [ -n "$_os" ] && [[ $? != 0 || "$_name" == "store" ]]; then
        case $_os in
            linux)
                # Try to use KWallet if available
                _ask=$(command -v ksshaskpass) > /dev/null && \
                $gfg core.askpass "$_ask"

                # Try to use Gnome-Keyring if available
                command -v gnome-keyring > /dev/null && \
                $gfg $_name gnome-keyring;
            ;;
            osx)
                $gfg $_name osxkeychain;
            ;;
            windows)
                $gfg $_name wincred;
            ;;
        esac
    fi
}

init_dotfiles() {

    # A method to move existing .profile to .extend.profile or .profile.bak
    _toextend() {
        local name=$1
        if [ -s ~/".$name" ] && [ ! -L ~/".$name" ]; then
            local extend=.extend.$name
            if [ -s ~/"$extend" ]; then
                [ -s ~/".$name.bak" ] && echo "Overwriting ~/.$name.bak"
                mv -- ~/".$name" ~/".$name.bak"
            else
                # Old .profile becomes .extend.profile
                mv -- ~/".$name" ~/"$extend" && \

                # Avoid recursive sourcing
                sed -ri "s/((^|^[^#]*\s)(\.|source)\s+(\~|\\\$HOME)\/$extend)/#\\1/" ~/"$extend"
            fi
        fi
    }

    local i _i _rc _pc

    ln -sf "$_dotfiles/source" ~/.source

    # Try to take care of sourcing .source automatically
    _shell=$(shelltype)
    _rc=~/".${_shell}rc";
    _pc=~/.profile
    if [ -n "$_shell" ]; then
        if [ ! -e "$_rc" ] || is_sourced "~/.profile" "$_rc"; then
            _i="$_pc"
        else
            _i="$_rc"
        fi

        if is_dotfiles_sourced "$_i"; then
            i=${_is_sourced:-"$_dotfiles/source"}
            echo "'$i' sourced in '$_i'"
        else
            i=~/.source
            if [ "$(readlink "$i")" = "$_dotfiles/source" ]; then
                i="~/.source"
            else
                i="$_dotfiles/source"
            fi

            echo "Adding '. $i' to $_i ..."
            echo "" >> "$_i"
            echo ". $i" >> "$_i"
        fi
    fi

    # _toextend profile && \
    # ln -sf "$_dotfiles/.profile" ~/

    _toextend aliasrc && \
    ln -sf "$_dotfiles/.aliasrc" ~/

    ln -s "$_dotfiles/.gitignore" ~/
    ln -s "$_dotfiles/.curlrc" ~/
    ln -s "$_dotfiles/.vimrc" ~/

    # unset -f _toextend

    exists "$_dotfiles/.extend.*" && for _i in "$_dotfiles"/.extend.*; do
        i=$(basename "$_i")
        _mark="#dotfiles: $i";
        if [ -e ~/"$i" ] && grep "$_mark" ~/"$i" > /dev/null; then
            echo "$i not updated"
        else
            echo "Updating $i ..."
            {
                echo "";
                cat "$_i";
                echo "";
                echo "$_mark";
            } >> ~/"$i";
        fi
    done

    if command -v git > /dev/null ; then
        echo -n "Init git?";
        read -p " [Y/n]" -n 1 -r;
        echo "";
        if [[ "${REPLY:-Y}" =~ ^[Yy]?$ ]]; then
            init_git "$@" # -f for forced update of the config, even when set
        fi
    fi

    # [ -n "$_e" ] && [ "$_e" -eq "1" ] && shopt -u expand_aliases
}

# ------------------------------------------------------------------------------
dotfiles_url() {
    ( git --git-dir="$_dotfiles/../.git" remote get-url origin 2> /dev/null || \
    git --git-dir="$_dotfiles/../.git" config --get remote.origin.url ) | git2url
}

# ------------------------------------------------------------------------------
alias .cd="cd '$_dotfiles/..'"
alias .source=". '$_dotfiles/source'"
alias .update="( cd '$(dirname "$_dotfiles")' && git pull --rebase --recurse-submodules) && .source"
alias .open_git="open \"\$(dotfiles_url)\""

# ------------------------------------------------------------------------------
[ -n "$_shell" ] && [ -f "$_dotfiles/.aliasrc.$_shell" ] && . "$_dotfiles/.aliasrc.$_shell";
[ -n "$_os" ] && [ -f "$_dotfiles/.aliasrc.$_os" ] && . "$_dotfiles/.aliasrc.$_os";
[ -f ~/.extend.aliasrc ] && . ~/.extend.aliasrc;
